-- These triggers behave more like PostgreSQL's default-from-sequence feature.

-- Work around a bering bug: it can't handle a PL/SQL block
-- at the top of a file.
SELECT SYSDATE FROM DUAL;

CREATE OR REPLACE TRIGGER SET_CSM_USER_GROU_USER_GROUP_R
BEFORE INSERT
ON CSM_USER_GROUP_ROLE_PG
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.USER_GROUP_ROLE_PG_ID IS NULL THEN
    SELECT CSM_USER_GROU_USER_GROUP_R_SEQ.NEXTVAL
      INTO :NEW.USER_GROUP_ROLE_PG_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_PG_PE_PG_PE_ID
BEFORE INSERT
ON CSM_PG_PE
FOR EACH ROW
BEGIN
  IF :NEW.PG_PE_ID IS NULL THEN
    SELECT CSM_PG_PE_PG_PE_ID_SEQ.NEXTVAL
      INTO :NEW.PG_PE_ID
      FROM dual;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER SET_CSM_ROLE_PRIV_ROLE_PRIVILE
BEFORE INSERT
ON CSM_ROLE_PRIVILEGE
FOR EACH ROW
BEGIN
  IF :NEW.ROLE_PRIVILEGE_ID IS NULL THEN
    SELECT CSM_ROLE_PRIV_ROLE_PRIVILE_SEQ.NEXTVAL
      INTO :NEW.ROLE_PRIVILEGE_ID
      FROM dual;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER SET_CSM_USER_GROU_USER_GROUP_I
BEFORE INSERT
ON CSM_USER_GROUP
FOR EACH ROW
BEGIN
  IF :NEW.USER_GROUP_ID IS NULL THEN
    SELECT CSM_USER_GROU_USER_GROUP_I_SEQ.NEXTVAL
      INTO :NEW.USER_GROUP_ID
      FROM dual;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER SET_CSM_USER_PE_USER_PROTECTIO
BEFORE INSERT
ON CSM_USER_PE
FOR EACH ROW
BEGIN
  IF :NEW.USER_PROTECTION_ELEMENT_ID IS NULL THEN
    SELECT CSM_USER_PE_USER_PROTECTIO_SEQ.NEXTVAL
      INTO :NEW.USER_PROTECTION_ELEMENT_ID
      FROM dual;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER SET_CSM_MAPPING_MAPPING_ID
BEFORE INSERT
ON CSM_MAPPING
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.MAPPING_ID IS NULL THEN
    SELECT CSM_MAPPING_MAPPING_ID_SEQ.NEXTVAL
      INTO :NEW.MAPPING_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_GROUP_GROUP_ID
BEFORE INSERT
ON CSM_GROUP
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.GROUP_ID IS NULL THEN
    SELECT CSM_GROUP_GROUP_ID_SEQ.NEXTVAL
      INTO :NEW.GROUP_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_PRIVILEGE_PRIVILEGE_ID
BEFORE INSERT
ON CSM_PRIVILEGE
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.PRIVILEGE_ID IS NULL THEN
    SELECT CSM_PRIVILEGE_PRIVILEGE_ID_SEQ.NEXTVAL
      INTO :NEW.PRIVILEGE_ID
      FROM dual;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER SET_CSM_FILTER_CLAUSE_FILTE_ID
BEFORE INSERT
ON CSM_FILTER_CLAUSE
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.FILTER_CLAUSE_ID IS NULL THEN
    SELECT CSM_FILTER_CLAUSE_FILTE_ID_SEQ.NEXTVAL
      INTO :NEW.FILTER_CLAUSE_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_PROTECTIO_PROTECTION_E
BEFORE INSERT
ON CSM_PROTECTION_ELEMENT
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.PROTECTION_ELEMENT_ID IS NULL THEN
    SELECT CSM_PROTECTIO_PROTECTION_E_SEQ.NEXTVAL
      INTO :NEW.PROTECTION_ELEMENT_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_PROTECTIO_PROTECTION_G
BEFORE INSERT
ON CSM_PROTECTION_GROUP
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.PROTECTION_GROUP_ID IS NULL THEN
    SELECT CSM_PROTECTIO_PROTECTION_G_SEQ.NEXTVAL
      INTO :NEW.PROTECTION_GROUP_ID
      FROM dual;
  END IF;
END ;
/

CREATE OR REPLACE TRIGGER SET_CSM_ROLE_ROLE_ID
BEFORE INSERT
ON CSM_ROLE
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
BEGIN
  IF :NEW.ROLE_ID IS NULL THEN
    SELECT CSM_ROLE_ROLE_ID_SEQ.NEXTVAL
      INTO :NEW.ROLE_ID
      FROM dual;
  END IF;
END ;
/

-- Work around a bering bug: it can't handle a PL/SQL block
-- at the end of a file.
SELECT SYSDATE FROM DUAL;